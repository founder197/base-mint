<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Mini Race — Jogo de Corrida (HTML5)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#071126; --accent:#ffcc33; --accent2:#56e6c2; --muted:#9fb0c8;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#020617,#07102a);color:var(--muted)}
  .wrap{width:min(980px,98vw);max-width:980px;margin:12px auto;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 8px 40px rgba(0,0,0,0.6)}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px}
  h1{font-size:18px;margin:0;color:white}
  .hud{display:flex;gap:10px;align-items:center;font-weight:600}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
  .btn.primary{border-color:var(--accent);color:var(--accent)}
  canvas{width:100%;height:64vh;max-height:760px;border-radius:10px;display:block;background:#061427}
  .controls-row{display:flex;gap:8px;align-items:center;margin-top:8px;justify-content:space-between}
  .small{font-size:13px;color:var(--muted)}
  .overlay{position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{background:rgba(3,6,9,0.65);padding:12px;border-radius:10px;color:white;backdrop-filter:blur(4px)}
  .touch-btn{position:fixed;bottom:18px;width:40%;height:64px;border-radius:12px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:space-around;left:10px;right:10px;margin:auto;max-width:980px}
  .small-btn{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted)}
  @media (max-width:520px){
    .touch-btn{height:72px}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Mini Race</h1>
    <div class="hud">
      <div>Velocidade: <span id="speed">0</span></div>
      <div>Pontuação: <span id="score">0</span></div>
      <div>Recorde: <span id="best">0</span></div>
    </div>
  </header>

  <div style="position:relative;">
    <canvas id="game"></canvas>

    <div id="overlay" class="overlay" style="pointer-events:none">
      <div id="menu" class="panel" style="pointer-events:auto">
        <div style="display:flex;gap:8px;align-items:center;justify-content:center">
          <button id="startBtn" class="btn primary">Iniciar</button>
          <button id="resumeBtn" class="btn" style="display:none">Continuar</button>
          <button id="resetBtn" class="btn">Reiniciar</button>
        </div>
        <div style="margin-top:8px;text-align:center" class="small">
          Controles: ← → / A D / toque nas laterais do ecrã. Incluir tilt nas configurações (permite inclinar o celular).
        </div>
      </div>
    </div>
  </div>

  <div class="controls-row">
    <div class="small">Evite carros e barreiras — pegue power-ups para +velocidade ou escudo.</div>
    <div>
      <button id="tiltBtn" class="btn small-btn">Tilt: OFF</button>
      <button id="soundBtn" class="btn small-btn">Som: ON</button>
    </div>
  </div>

  <div class="touch-btn" id="touchControls" style="display:none;position:relative">
    <button id="leftTouch" class="small-btn" style="width:45%">⟵</button>
    <button id="rightTouch" class="small-btn" style="width:45%">⟶</button>
  </div>
</div>

<script>
(() => {
  // Canvas setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha: false});
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const bestEl = document.getElementById('best');
  const overlay = document.getElementById('overlay');
  const menu = document.getElementById('menu');
  const startBtn = document.getElementById('startBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const resetBtn = document.getElementById('resetBtn');
  const tiltBtn = document.getElementById('tiltBtn');
  const soundBtn = document.getElementById('soundBtn');
  const touchControls = document.getElementById('touchControls');
  const leftTouch = document.getElementById('leftTouch');
  const rightTouch = document.getElementById('rightTouch');

  // responsive sizing
  function fit(){
    const ratio = devicePixelRatio || 1;
    canvas.style.height = Math.min(window.innerHeight * 0.64, 760) + 'px';
    canvas.width = Math.floor(canvas.clientWidth * ratio);
    canvas.height = Math.floor(parseFloat(getComputedStyle(canvas).height) * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);
  }
  window.addEventListener('resize', fit);
  fit();

  // Game variables
  let W = canvas.clientWidth, H = parseFloat(getComputedStyle(canvas).height);
  let raf, last = performance.now();
  let running = false;
  let paused = false;

  // player car
  const player = {
    x: 0, y: 0, w: 44, h: 88, laneX: 0, speed: 0, maxSpeed: 8, acc: 0.06, dec: 0.12,
    color: '#ffcc33', shield: 0
  };

  // road configuration (3 lanes)
  const lanes = 3;
  let laneWidth;
  let roadMargin = 40;

  // obstacles and opponents
  let obstacles = []; // {x,y,w,h,type,vy}
  let pickups = []; // {x,y,r,type,vy}
  let spawnTimer = 0;
  let pickupTimer = 0;

  // game stats
  let score = 0;
  let best = parseInt(localStorage.getItem('mini_race_best') || '0', 10) || 0;
  bestEl.textContent = best;
  scoreEl.textContent = score;
  speedEl.textContent = 0;

  // settings
  let tiltEnabled = false;
  let soundOn = true;
  let touchMode = ('ontouchstart' in window);
  if(touchMode) touchControls.style.display = 'flex';

  // simple sounds (WebAudio)
  const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
  function playBeep(freq=330,duration=0.08,vol=0.06){
    if(!audioCtx || !soundOn) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + duration);
  }

  // helpers
  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // initialize positions / reset
  function resetGame(){
    W = canvas.clientWidth; H = parseFloat(getComputedStyle(canvas).height);
    laneWidth = (W - roadMargin*2) / lanes;
    player.x = W/2;
    player.laneX = Math.floor(lanes/2);
    player.x = roadMargin + laneWidth * player.laneX + laneWidth/2;
    player.y = H - player.h - 16;
    player.speed = 0.8;
    player.shield = 0;
    obstacles = [];
    pickups = [];
    spawnTimer = 0;
    pickupTimer = 0;
    score = 0;
    scoreEl.textContent = score;
    speedEl.textContent = Math.floor(player.speed*10);
    overlay.style.display = 'flex';
    menu.style.display = 'block';
    resumeBtn.style.display = 'none';
  }

  // start / resume
  function startGame(){
    overlay.style.display = 'none';
    menu.style.display = 'none';
    running = true;
    paused = false;
    last = performance.now();
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    loop();
  }

  function pauseGame(){
    paused = true;
    overlay.style.display = 'flex';
    menu.style.display = 'block';
    resumeBtn.style.display = 'inline-block';
  }

  // spawning obstacles
  function spawnObstacle(){
    // types: car, cone, wall
    const lane = Math.floor(rand(0, lanes));
    const x = roadMargin + laneWidth*lane + laneWidth/2;
    const typeRand = Math.random();
    let type = 'car';
    let w = laneWidth*0.6, h = 84, vy = 1.6 + score*0.02;
    if(typeRand < 0.12){ type='wall'; w = laneWidth*0.9; h = 28; vy = 1.8 + score*0.03; }
    else if(typeRand < 0.28){ type='cone'; w = laneWidth*0.45; h = 36; vy = 1.7 + score*0.02; }
    const y = -h - 40;
    obstacles.push({x,y,w,h,type,lane,vy});
  }

  function spawnPickup(){
    const lane = Math.floor(rand(0, lanes));
    const x = roadMargin + laneWidth*lane + laneWidth/2;
    const typeRand = Math.random();
    let type = 'boost';
    if(typeRand < 0.45) type = 'boost';
    else if(typeRand < 0.75) type = 'coin';
    else type = 'shield';
    pickups.push({x,y:-40,r:14,type,lane,vy:1.6 + score*0.02});
  }

  // input handling
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'Escape') pauseGame();
    if(e.key === 'p') { if(paused) startGame(); else pauseGame(); }
  });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  // touch left/right
  leftTouch.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys['lefttouch']=true; }, {passive:false});
  leftTouch.addEventListener('touchend', (e)=>{ e.preventDefault(); keys['lefttouch']=false; }, {passive:false});
  rightTouch.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys['righttouch']=true; }, {passive:false});
  rightTouch.addEventListener('touchend', (e)=>{ e.preventDefault(); keys['righttouch']=false; }, {passive:false});

  // device tilt support
  let tiltX = 0;
  window.addEventListener('deviceorientation', (ev)=>{
    if(!tiltEnabled) return;
    // gamma is left-right tilt in degrees [-90,90]
    const g = ev.gamma || 0;
    tiltX = clamp(g / 30, -1, 1);
  });

  // touch swipe to steer (alternative)
  let touchStartX = null;
  canvas.addEventListener('touchstart', (e)=>{
    const t = e.touches[0];
    touchStartX = t.clientX;
  }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    if(touchStartX === null) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    if(Math.abs(dx) > 30){
      if(dx < 0) moveLeft(); else moveRight();
    }
    touchStartX = null;
  }, {passive:true});

  // steering functions
  function moveLeft(){ player.laneX = clamp(player.laneX - 1, 0, lanes-1); playBeep(240,0.06,0.05); }
  function moveRight(){ player.laneX = clamp(player.laneX + 1, 0, lanes-1); playBeep(480,0.06,0.05); }

  // collision helper (circle vs rect or rect vs rect)
  function rectsIntersect(a,b){
    return !(a.x + a.w/2 < b.x - b.w/2 || a.x - a.w/2 > b.x + b.w/2 || a.y + a.h/2 < b.y - b.h/2 || a.y - a.h/2 > b.y + b.h/2);
  }

  // draw loop
  function draw(){
    W = canvas.clientWidth; H = parseFloat(getComputedStyle(canvas).height);
    laneWidth = (W - roadMargin*2) / lanes;
    // background road
    ctx.fillStyle = '#041424';
    ctx.fillRect(0,0,W,H);
    // side grass
    ctx.fillStyle = '#031518';
    ctx.fillRect(0,0,roadMargin,H);
    ctx.fillRect(W-roadMargin,0,roadMargin,H);

    // draw road stripes (perspective motion)
    const stripeW = laneWidth*0.08;
    for(let i=0;i<lanes-1;i++){
      const stripeX = roadMargin + laneWidth*(i+1) - stripeW/2;
      // dashed center stripe
      ctx.fillStyle = 'rgba(255,255,255,0.07)';
      for(let y=-200 + (frame* (player.speed*8) % 40); y<H+200; y+=40){
        ctx.fillRect(stripeX + stripeW/2 - 2, y, 4, 22);
      }
    }

    // draw road border
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 2;
    ctx.strokeRect(roadMargin, 8, W-roadMargin*2, H-16);

    // draw pickups
    for(const p of pickups){
      const px = p.x, py = p.y;
      ctx.save();
      if(p.type === 'boost'){
        ctx.fillStyle = '#ffcc33';
        ctx.beginPath(); ctx.ellipse(px,py,p.r*1.2,p.r,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; ctx.fillText('B', px-4, py+4);
      } else if(p.type === 'coin'){
        ctx.fillStyle = '#ffd166';
        ctx.beginPath(); ctx.arc(px,py,p.r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; ctx.fillText('¢', px-5, py+5);
      } else {
        ctx.fillStyle = '#56e6c2';
        ctx.beginPath(); ctx.moveTo(px,py-p.r); ctx.lineTo(px+p.r,py+p.r); ctx.lineTo(px-p.r,py+p.r); ctx.closePath(); ctx.fill();
      }
      ctx.restore();
    }

    // draw obstacles
    for(const o of obstacles){
      const ox = o.x, oy = o.y;
      ctx.save();
      if(o.type === 'car'){
        ctx.fillStyle = '#c24d4d';
        ctx.fillRect(ox - o.w/2, oy - o.h/2, o.w, o.h);
        // windows
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(ox - o.w/4, oy - o.h/4, o.w/2, o.h/4);
      } else if(o.type === 'cone'){
        ctx.fillStyle = '#ff7b2d';
        ctx.beginPath(); ctx.moveTo(ox, oy - o.h/2); ctx.lineTo(ox + o.w/2, oy + o.h/2); ctx.lineTo(ox - o.w/2, oy + o.h/2); ctx.closePath(); ctx.fill();
      } else {
        ctx.fillStyle = '#444';
        ctx.fillRect(ox - o.w/2, oy - o.h/2, o.w, o.h);
      }
      ctx.restore();
    }

    // draw player
    // smooth lane x
    const targetX = roadMargin + laneWidth*player.laneX + laneWidth/2;
    player.x += (targetX - player.x) * 0.24;
    ctx.save();
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.beginPath();
    ctx.ellipse(player.x, player.y + player.h*0.5, player.w*0.9, player.h*0.18, 0, 0, Math.PI*2);
    ctx.fill();
    // car body
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h);
    // wheels
    ctx.fillStyle = '#111';
    ctx.fillRect(player.x - player.w/2 + 6, player.y + player.h/2 - 12, 12, 8);
    ctx.fillRect(player.x + player.w/2 - 18, player.y + player.h/2 - 12, 12, 8);
    // shield
    if(player.shield > 0){
      ctx.strokeStyle = 'rgba(86,230,194,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(player.x, player.y, player.w*0.9, player.h*0.9, 0, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();

    // HUD overlays drawn on canvas (distance lines)
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    ctx.fillRect(0, H-12, W, 12);
    ctx.restore();

  }

  // update physics & game
  let frame = 0;
  function update(dt){
    frame++;
    // controls: keyboard or tilt or touch
    if((keys['arrowleft'] || keys['a'] || keys['left'] || keys['lefttouch'])) moveLeftIfAllowed();
    if((keys['arrowright'] || keys['d'] || keys['right'] || keys['righttouch'])) moveRightIfAllowed();
    if(tiltEnabled && Math.abs(tiltX) > 0.35){
      if(tiltX < 0) moveLeftIfAllowed(); else moveRightIfAllowed();
    }
    // speed logic: ramp up slowly
    player.speed += player.acc * dt * 60;
    player.speed = clamp(player.speed, 0.8, player.maxSpeed + Math.min(5, score*0.02));
    speedEl.textContent = Math.floor(player.speed*10);

    // spawn obstacles progressively
    spawnTimer -= dt * 60 * (0.6 + player.speed*0.08);
    if(spawnTimer <= 0){
      spawnObstacle();
      spawnTimer = clamp(40 - score*0.6, 14, 40);
    }
    pickupTimer -= dt * 60;
    if(pickupTimer <= 0){
      spawnPickup();
      pickupTimer = clamp(80 - score*0.6, 40, 120);
    }

    // move obstacles and pickups downward (towards player)
    for(const o of obstacles){
      o.y += o.vy * player.speed * dt * 60;
    }
    for(const p of pickups){
      p.y += p.vy * player.speed * dt * 60;
    }

    // remove off-screen
    obstacles = obstacles.filter(o => o.y < H + 200);
    pickups = pickups.filter(p => p.y < H + 200);

    // collisions
    const playerRect = {x: player.x, y: player.y, w: player.w, h: player.h};
    // obstacles
    for(let i=0;i<obstacles.length;i++){
      const o = obstacles[i];
      const oRect = {x:o.x, y:o.y, w:o.w, h:o.h};
      if(rectsIntersect(playerRect, oRect)){
        if(player.shield > 0){
          player.shield -= 1;
          obstacles.splice(i,1);
          playBeep(120,0.08,0.08);
          score += 2;
          continue;
        }
        // hit: slow down & lose score
        player.speed = Math.max(0.6, player.speed - 2.4);
        obstacles.splice(i,1);
        score = Math.max(0, score - 3);
        playBeep(120,0.12,0.18);
      }
    }
    // pickups
    for(let i=0;i<pickups.length;i++){
      const p = pickups[i];
      const pr = {x:p.x, y:p.y, w:p.r*2, h:p.r*2};
      if(rectsIntersect(playerRect, pr)){
        if(p.type === 'boost'){
          player.speed = clamp(player.speed + 3.2, 0.8, player.maxSpeed + 8);
          score += 5;
          playBeep(800,0.06,0.08);
        } else if(p.type === 'coin'){
          score += 2;
          playBeep(900,0.06,0.06);
        } else if(p.type === 'shield'){
          player.shield = Math.min(3, player.shield + 2);
          playBeep(640,0.06,0.07);
        }
        pickups.splice(i,1);
      }
    }

    // accumulate score over time depending on speed
    score += Math.floor(player.speed * dt * 10);
    scoreEl.textContent = Math.floor(score);

    // update best
    if(score > best){
      best = Math.floor(score);
      bestEl.textContent = best;
      localStorage.setItem('mini_race_best', best);
    }

    // small auto difficulty: increase obstacle speed slightly over time
    // game over condition: if speed too low for too long? We'll keep it endless - but add occasional heavy obstacle that can knock out
  }

  // lane move helpers with rate limiting
  let lastMove = 0;
  function moveLeftIfAllowed(){
    const now = performance.now();
    if(now - lastMove < 160) return;
    lastMove = now;
    moveLeft();
  }
  function moveRightIfAllowed(){
    const now = performance.now();
    if(now - lastMove < 160) return;
    lastMove = now;
    moveRight();
  }

  // main loop
  function loop(now){
    raf = requestAnimationFrame(loop);
    now = now || performance.now();
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    if(running && !paused){
      update(dt);
      draw();
    }
  }

  // UI bindings
  startBtn.addEventListener('click', ()=>{ resetGame(); startGame(); });
  resumeBtn.addEventListener('click', ()=>{ overlay.style.display='none'; menu.style.display='none'; paused=false; last=performance.now(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });
  resetBtn.addEventListener('click', ()=>{ resetGame(); });

  tiltBtn.addEventListener('click', ()=>{
    tiltEnabled = !tiltEnabled;
    tiltBtn.textContent = (tiltEnabled ? 'Tilt: ON' : 'Tilt: OFF');
    if(tiltEnabled && audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  });

  soundBtn.addEventListener('click', ()=>{ soundOn = !soundOn; soundBtn.textContent = (soundOn ? 'Som: ON' : 'Som: OFF'); });

  // keyboard steering
  window.addEventListener('keydown', e => {
    if(['arrowleft','a'].includes(e.key.toLowerCase())) moveLeftIfAllowed();
    if(['arrowright','d'].includes(e.key.toLowerCase())) moveRightIfAllowed();
  });

  // mouse click to steer: left half -> left, right half -> right
  canvas.addEventListener('click', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    if(x < rect.width/2) moveLeftIfAllowed(); else moveRightIfAllowed();
  });

  // initial reset
  resetGame();

  // Mobile: resume audio on first touch if needed
  document.body.addEventListener('touchstart', function onFirstTouch(){
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    document.body.removeEventListener('touchstart', onFirstTouch);
  }, {passive:true});

  // small demo obstacles spawn to make menu lively
  // start the loop visually even when not running for menu preview
  let previewLast = performance.now();
  (function previewLoop(){
    requestAnimationFrame(previewLoop);
    const now = performance.now();
    const dt = Math.min(0.033, (now - previewLast) / 1000);
    previewLast = now;
    // draw a static scene so menu isn't blank
    draw();
  })();

})();
</script>
</body>
</html>