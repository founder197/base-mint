<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pong simples — Jogo em HTML/JS</title>
<style>
  :root{--bg:#0b0b0f;--fg:#e6e6e6;--accent:#2dd4bf}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#05060a,var(--bg));color:var(--fg)}
  #gameWrap{width:min(900px,95vw);max-width:900px;background:rgba(255,255,255,0.02);padding:12px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  h1{font-size:16px;margin:0;color:var(--fg)}
  #score{font-weight:600;color:var(--accent)}
  canvas{display:block;background:#020214;border-radius:8px;width:100%;height:60vh;max-height:640px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px;justify-content:space-between}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:var(--fg);cursor:pointer}
  .hint{opacity:0.7;font-size:13px}
  @media (max-width:420px){
    canvas{height:56vh}
    h1{font-size:14px}
  }
</style>
</head>
<body>
<div id="gameWrap">
  <header>
    <h1>Pong — HTML5</h1>
    <div id="score">0 : 0</div>
  </header>

  <canvas id="c"></canvas>

  <div class="controls">
    <div class="hint">Desktop: ↑ ↓ | Mobile: toque e arraste</div>
    <div>
      <button class="btn" id="startBtn">Iniciar / Reiniciar</button>
      <button class="btn" id="aiToggle">AI: ON</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  const scoreEl = document.getElementById('score');
  const startBtn = document.getElementById('startBtn');
  const aiToggle = document.getElementById('aiToggle');

  let W, H, raf;
  function resize() {
    const ratio = devicePixelRatio || 1;
    W = canvas.clientWidth;
    H = canvas.clientHeight;
    canvas.width = Math.floor(W * ratio);
    canvas.height = Math.floor(H * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);
  }
  // initial size
  resize();
  window.addEventListener('resize', resize);

  // Game objects
  const paddleW = 12;
  const paddleH = 90;
  const ballR = 8;

  const state = {
    left: { x: 20, y: 0, vy:0, score:0 },
    right: { x: 0, y:0, vy:0, score:0 },
    ball: { x:0, y:0, vx:0, vy:0 },
    running: false,
    aiOn: true,
    speedMult: 1
  };

  function resetPositions() {
    state.left.y = (H - paddleH)/2;
    state.right.x = W - 20 - paddleW;
    state.right.y = (H - paddleH)/2;
    state.ball.x = W/2;
    state.ball.y = H/2;
    const ang = (Math.random()*Math.PI/3) - Math.PI/6;
    const dir = Math.random() < 0.5 ? -1 : 1;
    state.ball.vx = dir * 6 * state.speedMult * (Math.random()*0.2 + 0.9);
    state.ball.vy = 6 * Math.tan(ang) * state.speedMult;
  }

  function startGame() {
    state.left.score = 0;
    state.right.score = 0;
    state.running = true;
    resetPositions();
    cancelAnimationFrame(raf);
    loop();
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function draw() {
    // background
    ctx.fillStyle = '#020214';
    ctx.fillRect(0,0,W,H);

    // middle dashed line
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 2;
    ctx.setLineDash([12,10]);
    ctx.beginPath();
    ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H);
    ctx.stroke();
    ctx.setLineDash([]);

    // paddles
    ctx.fillStyle = '#e6e6e6';
    roundRect(ctx, state.left.x, state.left.y, paddleW, paddleH, 6, true);
    roundRect(ctx, state.right.x, state.right.y, paddleW, paddleH, 6, true);

    // ball
    ctx.beginPath();
    ctx.fillStyle = '#2dd4bf';
    ctx.arc(state.ball.x, state.ball.y, ballR, 0, Math.PI*2);
    ctx.fill();

    // scores
    scoreEl.textContent = `${state.left.score} : ${state.right.score}`;
  }

  function roundRect(ctx,x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if(fill) ctx.fill();
  }

  // Update physics
  function update(dt) {
    // move ball
    state.ball.x += state.ball.vx * dt;
    state.ball.y += state.ball.vy * dt;

    // top/bottom collision
    if(state.ball.y - ballR < 0){
      state.ball.y = ballR;
      state.ball.vy *= -1;
    } else if(state.ball.y + ballR > H){
      state.ball.y = H - ballR;
      state.ball.vy *= -1;
    }

    // left paddle collision
    if(state.ball.x - ballR < state.left.x + paddleW){
      if(state.ball.y > state.left.y && state.ball.y < state.left.y + paddleH){
        state.ball.x = state.left.x + paddleW + ballR;
        state.ball.vx *= -1.03; // speed up a bit
        // add spin based on where it hit
        const rel = (state.ball.y - (state.left.y + paddleH/2)) / (paddleH/2);
        state.ball.vy += rel * 4;
      } else if(state.ball.x < 0){
        // right scores
        state.right.score++;
        resetPositions();
      }
    }

    // right paddle collision
    if(state.ball.x + ballR > state.right.x){
      if(state.ball.y > state.right.y && state.ball.y < state.right.y + paddleH){
        state.ball.x = state.right.x - ballR;
        state.ball.vx *= -1.03;
        const rel = (state.ball.y - (state.right.y + paddleH/2)) / (paddleH/2);
        state.ball.vy += rel * 4;
      } else if(state.ball.x > W){
        // left scores
        state.left.score++;
        resetPositions();
      }
    }

    // simple AI for right paddle
    if(state.aiOn){
      const target = state.ball.y - paddleH/2;
      const diff = target - state.right.y;
      state.right.y += clamp(diff, -6*state.speedMult, 6*state.speedMult) * dt * 60;
      state.right.y = clamp(state.right.y, 0, H - paddleH);
    }

    // ensure paddles stay inside
    state.left.y = clamp(state.left.y, 0, H - paddleH);
    state.right.y = clamp(state.right.y, 0, H - paddleH);
  }

  // main loop
  let last = performance.now();
  function loop(now){
    raf = requestAnimationFrame(loop);
    now = now || performance.now();
    const dt = Math.min(1/30, (now - last)/1000);
    last = now;
    if(state.running){
      update(dt);
      draw();
    }
  }

  // input handlers
  // keyboard: arrows move left paddle
  window.addEventListener('keydown', e => {
    if(e.key === 'ArrowUp') state.left.y -= 24;
    if(e.key === 'ArrowDown') state.left.y += 24;
  });

  // mouse / touch: drag on canvas to move left paddle
  let dragging = false;
  function pointerDown(e){
    dragging = true;
    moveToPointer(e);
  }
  function pointerUp(){ dragging = false; }
  function moveToPointer(e){
    const rect = canvas.getBoundingClientRect();
    const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
    const y = clientY - rect.top;
    state.left.y = y - paddleH/2;
  }
  canvas.addEventListener('mousedown', pointerDown);
  canvas.addEventListener('touchstart', pointerDown, {passive:true});
  window.addEventListener('mouseup', pointerUp);
  window.addEventListener('touchend', pointerUp);
  window.addEventListener('mousemove', e => { if(dragging) moveToPointer(e); });
  window.addEventListener('touchmove', e => { if(dragging) moveToPointer(e); }, {passive:true});

  // start button
  startBtn.addEventListener('click', () => {
    state.running = true;
    state.left.score = 0;
    state.right.score = 0;
    resetPositions();
    cancelAnimationFrame(raf);
    last = performance.now();
    loop();
  });

  aiToggle.addEventListener('click', () => {
    state.aiOn = !state.aiOn;
    aiToggle.textContent = state.aiOn ? 'AI: ON' : 'AI: OFF';
  });

  // initial small setup
  // set canvas CSS size based on wrap width
  function setupCanvasSize(){
    const wrap = document.getElementById('gameWrap');
    const w = Math.min(900, Math.max(320, wrap.clientWidth - 24));
    canvas.style.width = w + 'px';
    canvas.style.height = Math.floor(w * 0.65) + 'px';
    resize();
    state.right.x = parseFloat(getComputedStyle(canvas).width) - 20 - paddleW;
    resetPositions();
    draw();
  }
  setupCanvasSize();
  window.addEventListener('orientationchange', setupCanvasSize);
  window.addEventListener('resize', setupCanvasSize);
})();
</script>
</body>
</html>